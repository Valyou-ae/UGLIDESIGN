# CHAT STUDIO - PHASE 2 INTELLIGENCE

## üéØ Phase 2 Objectives

Build the intelligent agent system with learning capabilities:
- ‚úÖ Agent conversation logic with decision trees
- ‚úÖ Knowledge base integration (190+ styles, Cinematic DNA)
- ‚úÖ Context learning system (preference tracking)
- ‚úÖ Prompt enhancement engine
- ‚úÖ Project folder creation and management
- ‚úÖ Session persistence

## üìÅ Files to Create
```
src/
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ chatAgent.ts              # Main agent logic
‚îÇ   ‚îú‚îÄ‚îÄ contextManager.ts         # Learning system
‚îÇ   ‚îú‚îÄ‚îÄ promptEnhancer.ts         # Prompt building
‚îÇ   ‚îú‚îÄ‚îÄ projectManager.ts         # File operations
‚îÇ   ‚îî‚îÄ‚îÄ knowledgeBase.ts          # Styles/DNA access
‚îÇ
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ agent.types.ts            # Agent-specific types
‚îÇ   ‚îî‚îÄ‚îÄ context.types.ts          # Context/learning types
‚îÇ
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ conversationAnalyzer.ts   # Intent detection
    ‚îî‚îÄ‚îÄ patternRecognition.ts     # Preference analysis
```

---

## üìù Step 1: Extended Type Definitions

**File: `src/types/context.types.ts`**
```typescript
export interface ProjectContext {
  projectId: string;
  projectName: string;
  startTime: Date;
  conversationHistory: ChatMessage[];
  generatedImages: GeneratedImageRecord[];
  preferences: UserPreferences;
  projectTheme: ProjectTheme;
  progression: ProgressionState;
}

export interface UserPreferences {
  preferredStyles: string[];
  preferredAspectRatio: string;
  preferredCinematicElements: string[];
  rejectedElements: string[];
  colorPalette: string[];
  preferredMood: string;
  preferredLighting: string[];
  preferredCameras: string[];
}

export interface ProjectTheme {
  mainSubject: string;
  setting: string;
  consistencyKeywords: string[];
}

export interface ProgressionState {
  iteration: number;
  convergence: number; // 0-100
  momentum: 'exploring' | 'refining' | 'finalizing';
}

export interface GeneratedImageRecord {
  imageId: string;
  generationNumber: number;
  userPrompt: string;
  enhancedPrompt: string;
  parameters: GenerationParameters;
  imagePath: string;
  imageUrl: string;
  timestamp: Date;
  userFeedback: 'liked' | 'regenerated' | 'refined' | 'deleted' | null;
}

export interface GenerationParameters {
  style: string;
  aspectRatio: string;
  cinematicDNA: string[];
  colorPalette: string[];
  lighting: string;
  camera: string;
}
```

**File: `src/types/agent.types.ts`**
```typescript
import { OptionChip } from './chat.types';

export interface AgentResponse {
  message: string;
  options?: OptionChip[];
  enhancedPrompt?: string;
  showPromptPreview?: boolean;
  requiresGeneration?: boolean;
}

export interface Intent {
  action: 'generate' | 'refine' | 'explore' | 'converse';
  subject?: string;
  refinementType?: string;
  direction?: string;
  topic?: string;
  stage?: ConversationStage;
}

export type ConversationStage = 
  | 'initial'
  | 'subject-selection'
  | 'style-selection'
  | 'mood-selection'
  | 'ready-to-generate'
  | 'post-generation';

export interface KnowledgeBaseEntry {
  id: string;
  name: string;
  category: string;
  keywords: string;
  icon?: string;
  description?: string;
}
```

---

## üß† Step 2: Knowledge Base Service

**File: `src/services/knowledgeBase.ts`**
```typescript
import { KnowledgeBaseEntry } from '@/types/agent.types';

export class KnowledgeBase {
  // Sample styles - replace with your actual 190+ styles
  private styles: KnowledgeBaseEntry[] = [
    {
      id: 'cinematic',
      name: 'Cinematic',
      category: 'style',
      keywords: 'volumetric atmospheric effects, cinematic three-point lighting, shot on ARRI Alexa',
      icon: 'üé¨',
      description: 'Hollywood-quality cinematography with professional lighting'
    },
    {
      id: 'cyberpunk',
      name: 'Cyberpunk',
      category: 'style',
      keywords: 'neon lights, futuristic, volumetric fog, cyberpunk aesthetic, dark urban',
      icon: 'üåÉ',
      description: 'Futuristic dystopian aesthetic with neon elements'
    },
    {
      id: 'fantasy',
      name: 'Fantasy Art',
      category: 'style',
      keywords: 'magical, fantasy illustration, ethereal lighting, mystical atmosphere',
      icon: 'üßô',
      description: 'Magical and mystical fantasy artwork'
    },
    {
      id: 'realistic',
      name: 'Photorealistic',
      category: 'style',
      keywords: 'photorealistic, hyper-detailed, natural lighting, authentic textures',
      icon: 'üì∏',
      description: 'Ultra-realistic photographic quality'
    },
    {
      id: 'anime',
      name: 'Anime',
      category: 'style',
      keywords: 'anime style, manga aesthetic, cel-shaded, Japanese animation',
      icon: 'üéå',
      description: 'Japanese anime and manga style'
    }
  ];

  // Cinematic DNA components
  private cinematicDNA = {
    atmosphere: [
      'volumetric atmospheric fog',
      'god rays with light shafts',
      'atmospheric haze',
      'particle suspension'
    ],
    lighting: [
      'Rembrandt three-point lighting',
      'butterfly lighting',
      'dramatic shadows',
      'natural window light',
      'golden hour illumination'
    ],
    depth: [
      'layered composition',
      'foreground midground background',
      'depth of field separation',
      'atmospheric perspective'
    ],
    materials: [
      'subsurface scattering',
      'PBR materials',
      'realistic reflections',
      'physically accurate surfaces'
    ],
    cameras: [
      'shot on ARRI Alexa LF',
      'shot on RED Komodo 6K',
      'shot on Sony Venice',
      'shot on Phase One IQ4 150MP'
    ]
  };

  // Mood presets
  private moods = [
    { id: 'dramatic', name: 'Dramatic', keywords: 'dramatic lighting, high contrast, intense shadows' },
    { id: 'peaceful', name: 'Peaceful', keywords: 'soft lighting, gentle atmosphere, serene mood' },
    { id: 'mysterious', name: 'Mysterious', keywords: 'low-key lighting, atmospheric fog, enigmatic' },
    { id: 'vibrant', name: 'Vibrant', keywords: 'vivid colors, high saturation, energetic' },
    { id: 'dark', name: 'Dark', keywords: 'low-key, dark tones, moody shadows' },
    { id: 'ethereal', name: 'Ethereal', keywords: 'soft focus, dreamy, luminous atmosphere' }
  ];

  /**
   * Get all styles
   */
  getStyles(): KnowledgeBaseEntry[] {
    return this.styles;
  }

  /**
   * Get styles for specific subject
   */
  getStylesForSubject(subject: string): KnowledgeBaseEntry[] {
    const subjectLower = subject.toLowerCase();
    
    // Subject-specific style recommendations
    const subjectStyleMap: Record<string, string[]> = {
      'portrait': ['realistic', 'cinematic', 'artistic'],
      'landscape': ['cinematic', 'realistic', 'fantasy'],
      'fantasy': ['fantasy', 'anime', 'artistic'],
      'architecture': ['cinematic', 'realistic', 'minimalist'],
      'product': ['realistic', 'cinematic', 'minimalist']
    };

    const recommendedIds = subjectStyleMap[subjectLower] || ['cinematic', 'realistic'];
    return this.styles.filter(s => recommendedIds.includes(s.id));
  }

  /**
   * Get style details by ID
   */
  getStyleDetails(styleId: string): KnowledgeBaseEntry | undefined {
    return this.styles.find(s => s.id === styleId);
  }

  /**
   * Get cinematic DNA elements
   */
  getCinematicDNA(): typeof this.cinematicDNA {
    return this.cinematicDNA;
  }

  /**
   * Get mood presets
   */
  getMoods() {
    return this.moods;
  }

  /**
   * Get mood details
   */
  getMoodDetails(moodId: string) {
    return this.moods.find(m => m.id === moodId);
  }

  /**
   * Get recommended cinematic elements for style
   */
  getRecommendedCinematicElements(styleId: string): string[] {
    const recommendations: Record<string, string[]> = {
      'cinematic': ['volumetric atmospheric fog', 'Rembrandt three-point lighting', 'shot on ARRI Alexa LF'],
      'cyberpunk': ['volumetric fog', 'dramatic shadows', 'neon lighting'],
      'fantasy': ['god rays with light shafts', 'ethereal lighting', 'atmospheric haze'],
      'realistic': ['natural window light', 'subsurface scattering', 'PBR materials']
    };

    return recommendations[styleId] || [];
  }
}
```

---

## ü§ñ Step 3: Chat Agent Service

**File: `src/services/chatAgent.ts`**
```typescript
import { ContextManager } from './contextManager';
import { PromptEnhancer } from './promptEnhancer';
import { KnowledgeBase } from './knowledgeBase';
import { ProjectContext } from '@/types/context.types';
import { AgentResponse, Intent, ConversationStage } from '@/types/agent.types';
import { ChatMessage, OptionChip } from '@/types/chat.types';

export class ChatAgent {
  private contextManager: ContextManager;
  private promptEnhancer: PromptEnhancer;
  private knowledgeBase: KnowledgeBase;

  constructor() {
    this.contextManager = new ContextManager();
    this.promptEnhancer = new PromptEnhancer();
    this.knowledgeBase = new KnowledgeBase();
  }

  /**
   * Initialize new chat session
   */
  async initializeSession(): Promise<{ projectId: string; greeting: AgentResponse }> {
    const context = await this.contextManager.createNewContext();
    const greeting = this.getInitialGreeting();
    
    return {
      projectId: context.projectId,
      greeting
    };
  }

  /**
   * Process user message
   */
  async processMessage(
    message: string,
    projectId: string
  ): Promise<AgentResponse> {
    // Load context
    const context = await this.contextManager.loadContext(projectId);

    // Analyze intent
    const intent = this.analyzeIntent(message, context);

    // Update theme if subject detected
    if (intent.subject) {
      await this.contextManager.updateProjectTheme(
        intent.subject,
        '',
        projectId
      );
    }

    // Generate response based on intent
    const response = await this.generateResponse(intent, context);

    // Save message to history
    await this.contextManager.addMessage({
      id: Date.now().toString(),
      role: 'user',
      content: message,
      timestamp: new Date()
    }, projectId);

    await this.contextManager.addMessage({
      id: (Date.now() + 1).toString(),
      role: 'assistant',
      content: response.message,
      options: response.options,
      timestamp: new Date()
    }, projectId);

    return response;
  }

  /**
   * Build enhanced prompt for generation
   */
  async buildEnhancedPrompt(
    userPrompt: string,
    projectId: string
  ): Promise<string> {
    const context = await this.contextManager.loadContext(projectId);
    return this.promptEnhancer.enhance(userPrompt, context, this.knowledgeBase);
  }

  /**
   * Handle image feedback
   */
  async handleImageFeedback(
    imageId: string,
    action: 'liked' | 'regenerated' | 'refined' | 'deleted',
    projectId: string
  ): Promise<void> {
    const context = await this.contextManager.loadContext(projectId);
    
    // Find image
    const image = context.generatedImages.find(img => img.imageId === imageId);
    if (!image) return;

    // Update feedback
    image.userFeedback = action;

    // Learn from feedback
    if (action === 'liked') {
      await this.contextManager.reinforcePreferences(image.parameters, projectId);
      context.progression.convergence = Math.min(100, context.progression.convergence + 15);
    } else if (action === 'regenerated') {
      await this.contextManager.avoidElements(image.parameters, projectId);
      context.progression.convergence = Math.max(0, context.progression.convergence - 10);
    } else if (action === 'refined') {
      context.progression.convergence = Math.min(100, context.progression.convergence + 5);
    }

    // Update momentum
    if (context.progression.convergence > 75) {
      context.progression.momentum = 'finalizing';
    } else if (context.progression.convergence > 40) {
      context.progression.momentum = 'refining';
    } else {
      context.progression.momentum = 'exploring';
    }

    await this.contextManager.saveContext(context, projectId);
  }

  /**
   * Get initial greeting
   */
  private getInitialGreeting(): AgentResponse {
    return {
      message: "Hi! I'm your AI creative assistant. What would you like to create today?",
      options: [
        { label: 'Portrait', icon: 'üë§', value: 'portrait', type: 'quick' },
        { label: 'Landscape', icon: 'üåÑ', value: 'landscape', type: 'quick' },
        { label: 'Fantasy', icon: 'üêâ', value: 'fantasy', type: 'quick' },
        { label: 'Abstract', icon: 'üé®', value: 'abstract', type: 'quick' },
        { label: 'Architecture', icon: 'üèõÔ∏è', value: 'architecture', type: 'quick' },
        { label: 'Product', icon: 'üì¶', value: 'product', type: 'quick' },
        { label: 'Describe something else', icon: '‚úçÔ∏è', value: 'custom', type: 'custom' }
      ]
    };
  }

  /**
   * Analyze user intent
   */
  private analyzeIntent(message: string, context: ProjectContext): Intent {
    const lowerMessage = message.toLowerCase();

    // Detect subject from common keywords
    const subjects = ['portrait', 'landscape', 'fantasy', 'abstract', 'architecture', 'product'];
    const detectedSubject = subjects.find(s => lowerMessage.includes(s));

    // Check for generation request
    if (
      lowerMessage.includes('create') ||
      lowerMessage.includes('generate') ||
      lowerMessage.includes('make') ||
      detectedSubject
    ) {
      return {
        action: 'generate',
        subject: detectedSubject || this.extractSubject(message),
        stage: this.determineStage(context)
      };
    }

    // Check for refinement
    if (
      lowerMessage.includes('change') ||
      lowerMessage.includes('different') ||
      lowerMessage.includes('more') ||
      lowerMessage.includes('less')
    ) {
      return {
        action: 'refine',
        refinementType: this.extractRefinement(message)
      };
    }

    // Default to conversation
    return {
      action: 'converse',
      topic: message
    };
  }

  /**
   * Generate contextual response
   */
  private async generateResponse(
    intent: Intent,
    context: ProjectContext
  ): Promise<AgentResponse> {
    const stage = this.determineStage(context);

    // STAGE 1: Initial / Subject Selection
    if (stage === 'initial' || stage === 'subject-selection') {
      if (intent.subject) {
        // Subject selected, move to style
        return this.getStyleSelectionResponse(intent.subject);
      }
      return this.getInitialGreeting();
    }

    // STAGE 2: Style Selection
    if (stage === 'style-selection') {
      return this.getMoodSelectionResponse();
    }

    // STAGE 3: Mood Selection
    if (stage === 'mood-selection') {
      return this.getReadyToGenerateResponse(context);
    }

    // STAGE 4: Post-Generation
    if (stage === 'post-generation') {
      return this.getPostGenerationResponse(context);
    }

    // Default conversational response
    return {
      message: "I'm here to help you create amazing images! What would you like to do?",
      options: [
        { label: 'Generate Image', icon: 'üé®', value: 'generate', type: 'quick' },
        { label: 'Tell me more', icon: '‚úçÔ∏è', value: 'custom', type: 'custom' }
      ]
    };
  }

  /**
   * Get style selection response
   */
  private getStyleSelectionResponse(subject: string): AgentResponse {
    const styles = this.knowledgeBase.getStylesForSubject(subject);
    
    return {
      message: `Great choice! What style would you like for your ${subject}?`,
      options: [
        ...styles.map(style => ({
          label: style.name,
          icon: style.icon,
          value: style.id,
          type: 'quick' as const
        })),
        { label: 'Describe custom style', icon: '‚úçÔ∏è', value: 'custom', type: 'custom' as const }
      ]
    };
  }

  /**
   * Get mood selection response
   */
  private getMoodSelectionResponse(): AgentResponse {
    const moods = this.knowledgeBase.getMoods();
    
    return {
      message: "What mood or atmosphere should it have?",
      options: [
        ...moods.map(mood => ({
          label: mood.name,
          icon: this.getMoodIcon(mood.id),
          value: mood.id,
          type: 'quick' as const
        })),
        { label: 'Describe mood', icon: '‚úçÔ∏è', value: 'custom', type: 'custom' as const }
      ]
    };
  }

  /**
   * Get ready to generate response
   */
  private getReadyToGenerateResponse(context: ProjectContext): AgentResponse {
    const preview = this.buildGenerationPreview(context);
    
    return {
      message: `Perfect! I'm ready to create:\n\n${preview}\n\nShould I generate this?`,
      options: [
        { label: '‚úì Generate Now', icon: 'üé®', value: 'generate', type: 'quick' },
        { label: 'Edit Details', icon: '‚úèÔ∏è', value: 'edit', type: 'quick' },
        { label: 'Start Over', icon: 'üîÑ', value: 'restart', type: 'quick' }
      ],
      showPromptPreview: true,
      requiresGeneration: true
    };
  }

  /**
   * Get post-generation response
   */
  private getPostGenerationResponse(context: ProjectContext): AgentResponse {
    if (context.progression.convergence > 75) {
      return {
        message: "This looks great! What would you like to do next?",
        options: [
          { label: 'Create Variation', icon: 'üîÑ', value: 'variation', type: 'quick' },
          { label: 'Different Angle', icon: 'üìê', value: 'angle', type: 'quick' },
          { label: 'New Subject', icon: '‚ûï', value: 'new', type: 'quick' },
          { label: "I'm Done", icon: '‚úì', value: 'done', type: 'quick' },
          { label: 'Something else', icon: '‚úçÔ∏è', value: 'custom', type: 'custom' }
        ]
      };
    } else {
      return {
        message: "Let's refine this! What needs adjustment?",
        options: [
          { label: 'Change Colors', icon: 'üé®', value: 'colors', type: 'quick' },
          { label: 'Adjust Lighting', icon: 'üí°', value: 'lighting', type: 'quick' },
          { label: 'More Detail', icon: 'üîç', value: 'detail', type: 'quick' },
          { label: 'Different Style', icon: 'üñºÔ∏è', value: 'style', type: 'quick' },
          { label: 'Start Fresh', icon: 'üîÑ', value: 'regenerate', type: 'quick' },
          { label: 'Explain what\'s wrong', icon: '‚úçÔ∏è', value: 'custom', type: 'custom' }
        ]
      };
    }
  }

  /**
   * Determine conversation stage
   */
  private determineStage(context: ProjectContext): ConversationStage {
    if (context.conversationHistory.length <= 1) {
      return 'initial';
    }

    if (!context.projectTheme.mainSubject) {
      return 'subject-selection';
    }

    if (!context.preferences.preferredStyles || context.preferences.preferredStyles.length === 0) {
      return 'style-selection';
    }

    if (!context.preferences.preferredMood) {
      return 'mood-selection';
    }

    if (context.generatedImages.length === 0) {
      return 'ready-to-generate';
    }

    return 'post-generation';
  }

  /**
   * Build generation preview
   */
  private buildGenerationPreview(context: ProjectContext): string {
    const parts: string[] = [];

    if (context.projectTheme.mainSubject) {
      parts.push(`Subject: ${context.projectTheme.mainSubject}`);
    }

    if (context.preferences.preferredStyles.length > 0) {
      parts.push(`Style: ${context.preferences.preferredStyles[0]}`);
    }

    if (context.preferences.preferredMood) {
      parts.push(`Mood: ${context.preferences.preferredMood}`);
    }

    return parts.join('\n');
  }

  /**
   * Extract subject from message
   */
  private extractSubject(message: string): string {
    // Simple keyword extraction - enhance with NLP if needed
    const words = message.toLowerCase().split(' ');
    const subjects = ['portrait', 'landscape', 'dragon', 'castle', 'person', 'building'];
    return subjects.find(s => words.includes(s)) || 'image';
  }

  /**
   * Extract refinement type
   */
  private extractRefinement(message: string): string {
    const lowerMessage = message.toLowerCase();
    if (lowerMessage.includes('color')) return 'color';
    if (lowerMessage.includes('light')) return 'lighting';
    if (lowerMessage.includes('detail')) return 'detail';
    return 'general';
  }

  /**
   * Get mood icon
   */
  private getMoodIcon(moodId: string): string {
    const icons: Record<string, string> = {
      'dramatic': '‚ö°',
      'peaceful': 'üïäÔ∏è',
      'mysterious': 'üåô',
      'vibrant': 'üåà',
      'dark': 'üåë',
      'ethereal': '‚ú®'
    };
    return icons[moodId] || 'üé®';
  }
}
```

---

## üìä Step 4: Context Manager Service

**File: `src/services/contextManager.ts`**
```typescript
import { ProjectContext, UserPreferences, GenerationParameters } from '@/types/context.types';
import { ChatMessage } from '@/types/chat.types';

export class ContextManager {
  private contexts: Map<string, ProjectContext> = new Map();

  /**
   * Create new context
   */
  async createNewContext(projectName?: string): Promise<ProjectContext> {
    const projectId = this.generateId();
    const context: ProjectContext = {
      projectId,
      projectName: projectName || `New Project - ${this.formatDate(new Date())}`,
      startTime: new Date(),
      conversationHistory: [],
      generatedImages: [],
      preferences: {
        preferredStyles: [],
        preferredAspectRatio: '1:1',
        preferredCinematicElements: [],
        rejectedElements: [],
        colorPalette: [],
        preferredMood: '',
        preferredLighting: [],
        preferredCameras: []
      },
      projectTheme: {
        mainSubject: '',
        setting: '',
        consistencyKeywords: []
      },
      progression: {
        iteration: 0,
        convergence: 0,
        momentum: 'exploring'
      }
    };

    // Store in memory
    this.contexts.set(projectId, context);

    // Save to localStorage for persistence
    this.saveToLocalStorage(context);

    return context;
  }

  /**
   * Load context
   */
  async loadContext(projectId: string): Promise<ProjectContext> {
    // Try memory first
    let context = this.contexts.get(projectId);

    // Try localStorage if not in memory
    if (!context) {
      context = this.loadFromLocalStorage(projectId);
      if (context) {
        this.contexts.set(projectId, context);
      }
    }

    if (!context) {
      throw new Error(`Context not found: ${projectId}`);
    }

    return context;
  }

  /**
   * Save context
   */
  async saveContext(context: ProjectContext, projectId: string): Promise<void> {
    this.contexts.set(projectId, context);
    this.saveToLocalStorage(context);
  }

  /**
   * Add message to history
   */
  async addMessage(message: ChatMessage, projectId: string): Promise<void> {
    const context = await this.loadContext(projectId);
    context.conversationHistory.push(message);
    await this.saveContext(context, projectId);
  }

  /**
   * Update project theme
   */
  async updateProjectTheme(
    subject: string,
    setting: string,
    projectId: string
  ): Promise<void> {
    const context = await this.loadContext(projectId);

    context.projectTheme.mainSubject = subject;
    context.projectTheme.setting = setting;

    // Auto-generate better project name
    context.projectName = this.generateProjectName(subject, setting);

    await this.saveContext(context, projectId);
  }

  /**
   * Reinforce preferences (when user likes image)
   */
  async reinforcePreferences(
    parameters: GenerationParameters,
    projectId: string
  ): Promise<void> {
    const context = await this.loadContext(projectId);

    // Add style
    if (parameters.style && !context.preferences.preferredStyles.includes(parameters.style)) {
      context.preferences.preferredStyles.push(parameters.style);
    }

    // Add cinematic elements
    if (parameters.cinematicDNA) {
      parameters.cinematicDNA.forEach(element => {
        if (!context.preferences.preferredCinematicElements.includes(element)) {
          context.preferences.preferredCinematicElements.push(element);
        }
      });
    }

    // Add colors
    if (parameters.colorPalette) {
      parameters.colorPalette.forEach(color => {
        if (!context.preferences.colorPalette.includes(color)) {
          context.preferences.colorPalette.push(color);
        }
      });
    }

    await this.saveContext(context, projectId);
  }

  /**
   * Avoid elements (when user regenerates)
   */
  async avoidElements(
    parameters: GenerationParameters,
    projectId: string
  ): Promise<void> {
    const context = await this.loadContext(projectId);

    // Add to rejected elements
    if (parameters.style) {
      if (!context.preferences.rejectedElements.includes(parameters.style)) {
        context.preferences.rejectedElements.push(parameters.style);
      }
    }

    await this.saveContext(context, projectId);
  }

  /**
   * Add generated image to context
   */
  async addGeneratedImage(
    imageData: any,
    projectId: string
  ): Promise<void> {
    const context = await this.loadContext(projectId);

    context.generatedImages.push({
      imageId: this.generateId(),
      generationNumber: context.generatedImages.length + 1,
      userPrompt: imageData.userPrompt,
      enhancedPrompt: imageData.enhancedPrompt,
      parameters: imageData.parameters,
      imagePath: imageData.imagePath,
      imageUrl: imageData.imageUrl,
      timestamp: new Date(),
      userFeedback: null
    });

    context.progression.iteration++;

    await this.saveContext(context, projectId);
  }

  /**
   * Get all projects
   */
  getAllProjects(): ProjectContext[] {
    const projects: ProjectContext[] = [];
    
    // Load from localStorage
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith('chat-context-')) {
        const projectId = key.replace('chat-context-', '');
        const context = this.loadFromLocalStorage(projectId);
        if (context) {
          projects.push(context);
        }
      }
    }

    // Sort by most recent
    return projects.sort((a, b) => 
      new Date(b.startTime).getTime() - new Date(a.startTime).getTime()
    );
  }

  /**
   * Delete project
   */
  deleteProject(projectId: string): void {
    this.contexts.delete(projectId);
    localStorage.removeItem(`chat-context-${projectId}`);
  }

  // Private helpers

  private saveToLocalStorage(context: ProjectContext): void {
    localStorage.setItem(
      `chat-context-${context.projectId}`,
      JSON.stringify(context)
    );
  }

  private loadFromLocalStorage(projectId: string): ProjectContext | null {
    const data = localStorage.getItem(`chat-context-${projectId}`);
    if (!data) return null;

    try {
      return JSON.parse(data);
    } catch (error) {
      console.error('Error loading context:', error);
      return null;
    }
  }

  private generateProjectName(subject: string, setting: string): string {
    const date = this.formatDate(new Date());

    if (subject && setting) {
      return `${this.capitalize(subject)} ${this.capitalize(setting)} - ${date}`;
    } else if (subject) {
      return `${this.capitalize(subject)} Series - ${date}`;
    } else {
      return `Creative Project - ${date}`;
    }
  }

  private generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private formatDate(date: Date): string {
    return date.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric',
      year: 'numeric'
    });
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
```

---

## ‚ú® Step 5: Prompt Enhancer Service

**File: `src/services/promptEnhancer.ts`**
```typescript
import { ProjectContext } from '@/types/context.types';
import { KnowledgeBase } from './knowledgeBase';

export class PromptEnhancer {
  /**
   * Enhance user prompt with context and knowledge base
   */
  async enhance(
    userPrompt: string,
    context: ProjectContext,
    knowledgeBase: KnowledgeBase
  ): Promise<string> {
    let enhanced = userPrompt;

    // STAGE 1: Apply preferred style
    if (context.preferences.preferredStyles.length > 0) {
      const style = knowledgeBase.getStyleDetails(context.preferences.preferredStyles[0]);
      if (style) {
        enhanced += `, ${style.keywords}`;
      }
    }

    // STAGE 2: Apply cinematic DNA elements
    if (context.preferences.preferredCinematicElements.length > 0) {
      const elements = context.preferences.preferredCinematicElements.slice(0, 3).join(', ');
      enhanced += `, ${elements}`;
    }

    // STAGE 3: Apply color preferences
    if (context.preferences.colorPalette.length > 0) {
      const colors = context.preferences.colorPalette.slice(0, 3).join(', ');
      enhanced += `, color palette featuring ${colors}`;
    }

    // STAGE 4: Apply lighting preferences
    if (context.preferences.preferredLighting.length > 0) {
      enhanced += `, ${context.preferences.preferredLighting[0]}`;
    }

    // STAGE 5: Apply mood
    if (context.preferences.preferredMood) {
      const mood = knowledgeBase.getMoodDetails(context.preferences.preferredMood);
      if (mood) {
        enhanced += `, ${mood.keywords}`;
      }
    }

    // STAGE 6: Add default cinematic quality
    if (!enhanced.includes('volumetric')) {
      enhanced += ', volumetric atmospheric effects with god rays';
    }

    if (!enhanced.includes('lighting') && !enhanced.includes('light')) {
      enhanced += ', cinematic three-point lighting';
    }

    // STAGE 7: Add camera
    if (context.preferences.preferredCameras.length > 0) {
      enhanced += `, ${context.preferences.preferredCameras[0]}`;
    } else {
      enhanced += ', shot on Phase One IQ4 150MP';
    }

    // STAGE 8: Add quality markers
    enhanced += ', extreme detail, professional quality';

    return enhanced;
  }
}
```

---

## üîÑ Step 6: Update ChatInterface with Services

**File: `src/components/chat/ChatInterface.tsx` (Updated)**
```typescript
import React, { useState, useEffect, useRef } from 'react';
import { MessageThread } from './MessageThread';
import { MessageInput } from './MessageInput';
import { ChatMessage } from '@/types/chat.types';
import { ChatAgent } from '@/services/chatAgent';
import { ContextManager } from '@/services/contextManager';

interface ChatInterfaceProps {
  projectId?: string;
}

export const ChatInterface: React.FC<ChatInterfaceProps> = ({ projectId }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [currentProjectId, setCurrentProjectId] = useState<string>('');
  const [projectName, setProjectName] = useState<string>('New Project');
  
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const chatAgent = useRef(new ChatAgent()).current;
  const contextManager = useRef(new ContextManager()).current;

  // Initialize session
  useEffect(() => {
    const init = async () => {
      if (projectId) {
        // Load existing project
        const context = await contextManager.loadContext(projectId);
        setMessages(context.conversationHistory);
        setCurrentProjectId(projectId);
        setProjectName(context.projectName);
      } else {
        // Create new session
        const { projectId: newProjectId, greeting } = await chatAgent.initializeSession();
        setCurrentProjectId(newProjectId);
        
        const greetingMessage: ChatMessage = {
          id: '1',
          role: 'assistant',
          content: greeting.message,
          options: greeting.options,
          timestamp: new Date()
        };
        setMessages([greetingMessage]);
      }
    };

    init();
  }, [projectId]);

  // Auto-scroll
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Update project name when it changes
  useEffect(() => {
    const updateName = async () => {
      if (currentProjectId) {
        const context = await contextManager.loadContext(currentProjectId);
        setProjectName(context.projectName);
      }
    };
    updateName();
  }, [messages]);

  const handleSendMessage = async (content: string) => {
    if (!currentProjectId) return;

    // Add user message
    const userMessage: ChatMessage = {
      id: Date.now().toString(),
      role: 'user',
      content,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userMessage]);

    // Process with agent
    setIsLoading(true);
    try {
      const response = await chatAgent.processMessage(content, currentProjectId);

      // Check if generation is required
      if (response.requiresGeneration) {
        // Build enhanced prompt
        const enhancedPrompt = await chatAgent.buildEnhancedPrompt(content, currentProjectId);
        
        // TODO: Call your actual image generation API here
        // For now, show prompt preview
        const agentMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          role: 'assistant',
          content: `${response.message}\n\n**Enhanced Prompt:**\n${enhancedPrompt}`,
          options: response.options,
          timestamp: new Date()
        };
        setMessages(prev => [...prev, agentMessage]);
      } else {
        // Regular response
        const agentMessage: ChatMessage = {
          id: (Date.now() + 1).toString(),
          role: 'assistant',
          content: response.message,
          options: response.options,
          timestamp: new Date()
        };
        setMessages(prev => [...prev, agentMessage]);
      }
    } catch (error) {
      console.error('Error processing message:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="chat-interface">
      <header className="chat-header">
        <button 
          className="back-button"
          onClick={() => window.history.back()}
        >
          ‚Üê Back
        </button>
        <h1 className="chat-title">üí¨ Chat Studio</h1>
        <span className="project-name">{projectName}</span>
      </header>

      <div className="chat-messages-container">
        <MessageThread 
          messages={messages}
          isLoading={isLoading}
          onOptionSelect={handleSendMessage}
        />
        <div ref={messagesEndRef} />
      </div>

      <MessageInput 
        onSend={handleSendMessage}
        disabled={isLoading}
        placeholder="Type your message or select an option above..."
      />
    </div>
  );
};
```

---

## üè† Step 7: Update ChatStudioHome with Project List

**File: `src/pages/ChatStudioHome.tsx` (Updated)**
```typescript
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { ContextManager } from '@/services/contextManager';
import { ProjectContext } from '@/types/context.types';

export const ChatStudioHome: React.FC = () => {
  const navigate = useNavigate();
  const [projects, setProjects] = useState<ProjectContext[]>([]);
  const contextManager = new ContextManager();

  useEffect(() => {
    loadProjects();
  }, []);

  const loadProjects = () => {
    const allProjects = contextManager.getAllProjects();
    setProjects(allProjects);
  };

  const handleNewChat = () => {
    navigate('/chat-studio/new');
  };

  const handleOpenProject = (projectId: string) => {
    navigate(`/chat-studio/${projectId}`);
  };

  const handleDeleteProject = (projectId: string, e: React.MouseEvent) => {
    e.stopPropagation();
    if (confirm('Delete this conversation?')) {
      contextManager.deleteProject(projectId);
      loadProjects();
    }
  };

  return (
    <div className="chat-studio-home">
      <header className="studio-home-header">
        <h1>üí¨ Chat Studio</h1>
        <p>AI-powered conversational image generation</p>
      </header>

      <div className="studio-home-content">
        {/* Recent Chats Section */}
        <section className="recent-chats">
          <h2>Recent Conversations</h2>
          
          {projects.length === 0 ? (
            <div className="empty-state">
              <p>No previous conversations yet</p>
              <p className="empty-state-hint">Start a new chat to begin creating!</p>
            </div>
          ) : (
            <div className="project-list">
              {projects.map(project => (
                <div
                  key={project.projectId}
                  className="project-card"
                  onClick={() => handleOpenProject(project.projectId)}
                >
                  <div className="project-info">
                    <h3 className="project-name">{project.projectName}</h3>
                    <p className="project-meta">
                      {project.generatedImages.length} images ‚Ä¢ 
                      {project.conversationHistory.length} messages
                    </p>
                    <p className="project-date">
                      {new Date(project.startTime).toLocaleDateString()}
                    </p>
                  </div>
                  <button
                    className="delete-btn"
                    onClick={(e) => handleDeleteProject(project.projectId, e)}
                  >
                    üóëÔ∏è
                  </button>
                </div>
              ))}
            </div>
          )}
        </section>

        {/* New Chat Button */}
        <button 
          className="new-chat-button"
          onClick={handleNewChat}
        >
          <span className="button-icon">‚ûï</span>
          <span className="button-text">Start New Chat</span>
        </button>
      </div>
    </div>
  );
};
```

---

## üé® Step 8: Additional Styles for Project List

**Add to `src/styles/ChatStudio.css`**
```css
/* Project List */
.project-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.project-card {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1.5rem;
  background: #1a1a1a;
  border: 1px solid #2a2a2a;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.project-card:hover {
  background: #2a2a2a;
  border-color: #667eea;
  transform: translateY(-2px);
}

.project-info {
  flex: 1;
}

.project-name {
  font-size: 1.125rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
  color: #fff;
}

.project-meta {
  font-size: 0.875rem;
  color: #888;
  margin-bottom: 0.25rem;
}

.project-date {
  font-size: 0.75rem;
  color: #666;
}

.delete-btn {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  background: #2a2a2a;
  border: 1px solid #444;
  cursor: pointer;
  font-size: 1.25rem;
  transition: all 0.2s;
}

.delete-btn:hover {
  background: #ff4444;
  border-color: #ff4444;
}
```

---

## ‚úÖ Phase 2 Completion Checklist

- [ ] Create all service files
- [ ] Create type definition files
- [ ] Update ChatInterface with agent integration
- [ ] Update ChatStudioHome with project list
- [ ] Test conversation flow:
  - [ ] Subject selection ‚Üí Style selection ‚Üí Mood selection
  - [ ] Agent remembers preferences
  - [ ] Project name auto-updates
  - [ ] Conversation saves to localStorage
- [ ] Test project management:
  - [ ] Create multiple projects
  - [ ] View project list
  - [ ] Resume existing project
  - [ ] Delete project
- [ ] Test learning system:
  - [ ] Preferences update based on selections
  - [ ] Enhanced prompts include learned preferences
  - [ ] Context persists across sessions

---

## üéØ What Phase 2 Achieves

‚úÖ **Intelligent Conversations**
- Agent guides users through structured flow
- Contextual responses based on stage
- Smart option generation

‚úÖ **Knowledge Base Integration**
- Access to 190+ styles (sample provided)
- Cinematic DNA components
- Mood presets

‚úÖ **Learning System**
- Tracks user preferences
- Reinforces liked elements
- Avoids rejected elements
- Updates convergence score

‚úÖ **Prompt Enhancement**
- Builds complex prompts from simple input
- Applies learned preferences automatically
- Maintains project consistency

‚úÖ **Session Persistence**
- Projects save to localStorage
- Can resume conversations
- Project list with management

---

## üöÄ Next: Phase 3 Preview

Phase 3 will add:
- Image generation integration (Gemini API)
- Inline image display with actions
- Project context panel UI
- Advanced feedback learning
- Image file management
- Export/share capabilities

---

**Phase 2 Complete! Test the intelligent conversation flow before moving forward.**